BCSE205L
Computer Architecture and Organization

Dr. P.Keerthika 
Associate Professor
School of Computer Science and Engineering 
Vellore Institute of Technology, Vellore 

Module 7 ‚Äì High Performance Processors


Parallel Processing


Classification of Parallel Machine 
models - Flynn‚Äôs Taxonomy


Classification of Parallel Machine 
models - Flynn‚Äôs Taxonomy
Instruction Cycle


Flynn‚Äôs Taxonomy 
of Parallel Machine models
Classical Von-Neumann Architecture

Most Common and general Parallel Machine


Flynn‚Äôs Taxonomy 
of Parallel Machine models

Symmetric Multi Processor systems 
‚Äì Uniform Memory Access
Non - Uniform Memory Access


Flynn‚Äôs Taxonomy 
- SISD‚Ä¢ An SISD computing system -uniprocessor

machine - capable of executing a single 
instruction, operating on a single data 
stream.
‚Ä¢ In SISD, machine instructions are 
processed in a sequential manner and 
computers adopting this model are 
popularly called sequential computers.
‚Ä¢ Most conventional computers have SISD
architecture.
‚Ä¢ All the instructions and data to be
processed have to be stored in primary 
memory.


Flynn‚Äôs Taxonomy 
- SISD

This is the uniprocessor architecture 
CU= Control Unit
PE= Processing Element (same as ALU) 
M= Memory
IS= Instruction Stream
DS= Data Stream
ŒºIS= Micro-Instructions Stream


Flynn‚Äôs Taxonomy 
- SIMD


Flynn‚Äôs Taxonomy 
- SIMD
‚Ä¢ A SIMD system is a multiprocessor machine 
capable of executing the same instruction on 
all the CPUs but operating on different data 
streams.
‚Ä¢ Machines based on a SIMD model are well 
suited to scientific computing since they 
involve lots of vector and matrix operations.
‚Ä¢ Information can be passed to all the 
processing elements (PEs) organized data 
elements of vectors can be divided into 
multiple sets(N-sets for N-Processor systems) 
and each Processor can process one data set.

CU= Control Unit 
PE= Processing Element 
M= Memory
IS= Instruction Stream 
DS= Data Stream 
LM=Local Memory


Flynn‚Äôs Taxonomy 
- SIMD
‚Ä¢ At one time, one instruction operates on
many data
‚Ä¢ Data parallel architecture‚ÄìVector
architecture has similar characteristics, 
but achieve the parallelism with 
pipelining
‚Ä¢ Each instruction is executed on a different 
set of data by different processors i.e 
multiple processing units by different 
processors i.e multiple processing units of 
the same type process on multiple-data 
streams.
‚Ä¢ This group is dedicated to array processing
machines.
‚Ä¢ SIMD computers operate on vectors of data.


Flynn‚Äôs Taxonomy 
- MISD


Flynn‚Äôs Taxonomy 
- MISD
‚Ä¢ An MISD computing system is a multiprocessor machine 
capable of executing different instructions on different 
Processors but all of them operating on the same dataset
‚Ä¢ Each processor executes a different sequence of
instructions.
‚Ä¢ In case of MISD computers, multiple processing units
operate on one single-data stream .
‚Ä¢ In practice, this kind of organization has never been used


Flynn‚Äôs Taxonomy 
- MIMD


Flynn‚Äôs Taxonomy 
- MIMD
‚Ä¢ An MIMD system is a multiprocessor machine which is capable of executing
multiple instructions on multiple data sets.
‚Ä¢ Each Processor in the MIMD model has separate instruction and data streams;
therefore machines built using this model are capable to any kind of application. 
‚Ä¢ SMPs (Symmetric Multi Processor systems), clusters, and NUMA(Non-Uniform
Memory Access) systems fit into this category.
‚Ä¢ Most common and general parallel machine
‚Ä¢ Each processor has a separate program.
‚Ä¢ An instruction stream is generated from each program
‚Ä¢ Each instruction operates on different data.
‚Ä¢ Several processing units operate on multiple-data streams.


Flynn‚Äôs Taxonomy 
- MIMD
1. MIMD with shared memory
‚Ä¢ If the processors share a common memory, then
each processor accesses programs and data stored 
in the shared memory.
‚Ä¢ The processors also communicate with each other
via the shared memory.

2. MIMD with Distributed memory
‚Ä¢ An alternative to using a single shared memory is to
distribute the memory by subdividing it into a 
number of separate modules with each module 
assigned to a different processing element


Flynn‚Äôs Taxonomy 
- MIMD
3. MIMD with Shared or Distributed memory


BCSE205L
Computer Architecture and Organization
Module 7 ‚Äì Parallelism - Pipelining


Parallelism

‚Ä¢ Data Parallelism 
‚Ä¢ Parallelism w.r.t data
‚Ä¢ Many data items can be processed in the same manner at the same time 
‚Ä¢ SIMD or Vector processors
‚Ä¢ Functional Parallelism
‚Ä¢ Parallelism w.r.t modules
‚Ä¢ Program has different independent modules that can execute simultaneously 
‚Ä¢ Instruction-level Parallelism (ILP)
‚Ä¢ Parallelism w.r.t instructions
‚Ä¢ Family of processor and compiler design techniques that improves performance
‚Ä¢ Parallel or simultaneous execution of a sequence of instructions of a computer
program.
‚Ä¢ Measure of the number of instructions that can be performed during a single clock
cycle


Implementations of ILP

‚Ä¢ Pipelining
‚Ä¢ Superscalar Architecture
‚Ä¢ Dependency checking on chip 
‚Ä¢ Multiple Processing Elements (eg. ALU, Shift)
‚Ä¢ VLIW (Very Long Instruction Word Architecture)
‚Ä¢ Simple hardware, Complex Compiler 
‚Ä¢ Multi processor computers


Pipelining
‚Ä¢ Overlapping of instructions partially
‚Ä¢ Pipelining is a process of arrangement of hardware
elements of the CPU such that its overall 
performance is increased.
‚Ä¢ Simultaneous execution of more than one instruction
takes place in a pipelined processor.
‚Ä¢ Technique of decomposing a sequential process into
sub-operations, with each sub-operation being 
executed in a dedicated segment that operates 
concurrently with all other segments.
‚Ä¢ Pipelining improves instruction throughput rather
than individual instruction execution time

Non-pipelined Execution

Pipelined Execution


Ann, Brian, Cathy, Dave
Each has one load of clothes to 
wash,    dry,    fold.

washer 
30 mins

dryer
40 mins

folder 
20 mins

Pipelining 
Laundry Example


What would you do? 

Task Order

A
B
C
D

Time

30 40 20 30 40 20 30 40 20 30 40 20 

6 Hours

Pipelining

Sequential Laundry


What would you do? 

Task Order

A
B
C
D

Time

30 40 20 30 40 20 30 40 20 30 40 20 

6 Hours

Pipelining

Sequential Laundry


Observations
‚Ä¢ A task has a series of 
stages;
‚Ä¢ Stage dependency:
e.g., wash before dry; 
‚Ä¢ Multi tasks with 
overlapping stages;
‚Ä¢ Simultaneously use diff 
resources to speed up;
‚Ä¢ Slowest stage determines 
the finish time;

Task Order

A
B
C
D

Time

30 40 40 40 40 20 

3.5 Hours

Pipelining

Pipelined Laundry


Pipelined Laundry

Observations
‚Ä¢ No speed up for 
individual task; 
e.g., A still takes 
30+40+20=90
‚Ä¢ But speed up for average 
task execution time;
e.g., 3.5*60/4=52.5 < 
30+40+20=90

Task Order

A
B
C
D

Time

30 40 40 40 40 20 

3.5 Hours

Pipelining


‚Ä¢ An implementation technique whereby multiple instructions are
overlapped in execution. 
e.g., B wash while A dry

‚Ä¢ Essence: Start executing one instruction before completing the
previous one.
‚Ä¢ Significance: Make fast CPUs.

A
B

Pipelining


Pipelining

Fetch Execut
e

Instruction Pipelining 
Two Stage Pipeline

Four Stage Pipeline

Six Stage Pipeline


‚Ä¢ The pipeline has two independent stages.
‚Ä¢ First stage - fetches an instruction and buffers it. When the second
stage is free, the first stage passes it the buffered instruction.
‚Ä¢ Second stage - executing the instruction, the first stage takes
advantage of any unused memory cycles to fetch and buffer the next 
instruction. This is called instruction prefetch or fetch overlap.

Pipelining 
‚Äì Two Stage Instruction Pipelining


Pipelining 
‚Äì Two Stage Instruction Pipelining


Four stages:
‚Ä¢ Instruction Fetch (IF) from memory
‚Ä¢ Instruction Decode (ID) in CPU
‚Ä¢ Instruction Execution (IE) in ALU
‚Ä¢ Result Writing (RW) in memory or Register.
‚Ä¢ Since there are four stages, all the instructions pass through the four stages to
complete the instruction execution.

Pipelining 
‚Äì Four Stage Instruction Pipelining


Performance:
‚Ä¢ In 8 clock cycles, 5 instructions
have got executed in a four-stage 
pipelined design.
‚Ä¢ The same would have taken 20 (5 
instructions x 4 cycles for each) 
clock cycles in a non pipelined 
architecture.
‚Ä¢ The performance improvement 
depends on the number of stages 
in the design.

Pipelining 
‚Äì Four Stage Instruction Pipelining


Pipelining 
‚Äì Four Stage Instruction Pipelining


‚Ä¢ A typical instruction cycle can be split into many sub cycles like Fetch instruction, Decode
instruction, Execute and Store.
‚Ä¢ The instruction cycle and the corresponding sub cycles are performed for each instruction. These
sub cycles for different instructions can thus be interleaved or in other words these sub cycles of 
many instructions can be carried out simultaneously, resulting in reduced overall execution time. 
This is called instruction pipelining.
‚Ä¢ The more are the stages in the pipeline, the more the throughput is of the CPU.
‚Ä¢ If the instruction processing is split into six phases, the pipelined CPU will have six different
stages for the execution of the sub phases.

Pipelining 
‚Äì Six Stage Instruction Pipelining


Stages
‚Ä¢ Fetch Instruction (FI)
‚Ä¢ Decode Instruction ((DI) 
‚Ä¢ Calculate Operand (CO) 
‚Ä¢ Fetch Operands (FO)
‚Ä¢ Execute Instruction (EI) 
‚Ä¢ Write Operand (WO)

Pipelining 
‚Äì Six Stage Instruction Pipelining
‚Ä¢ FI: Instructions are fetched from the memory into a temporary
buffer before it gets executed.
‚Ä¢ DI: The instruction is decoded by the CPU so that the necessary
op codes and operands can be determined. (Instruction Decode) 
‚Ä¢ CO: Based on the addressing scheme used, either operands are
directly provided in the instruction or the effective address has 
to be calculated. (Address Generator)
‚Ä¢ FO: Once the address is calculated, the operands need to be 
fetched from the address that was calculated. This is done in this 
phase. (Data Fetch)
‚Ä¢ EI: The instruction can now be executed.
‚Ä¢ WO: Once the instruction is executed, the result from the
execution needs to be stored or written back in the memory. 
(Write Back)


Pipelining 
‚Äì Six Stage Instruction Pipelining

‚Ä¢ In case the time required by each of the sub phase is not same appropriate delays need to be
introduced.
‚Ä¢ From this timing diagram it is clear that the total execution time of 3 instructions in this 6 stages
pipeline is 8-time units.
‚Ä¢ The first instruction gets completed after 6 time unit, and thereafter in each time unit it
completes one instruction.
‚Ä¢ Without pipeline, the total time required to complete 3 instructions would have been 18 (6*3)
time units. Therefore, there is a speed up in pipeline processing and the speed up is related to the 
number of stages.


Pipelining


Speed Up and Efficiency
‚Ä¢ For a pipeline processor:
‚Ä¢ k-stage pipeline processes with a clock cycle time tp is used to execute n tasks.
‚Ä¢ The time required for the first task T1 to complete the operation = k*tp
(if k segments in the pipe)
‚Ä¢ The time required to complete (n-1) tasks = (n-1) *tp
‚Ä¢ Therefore to complete n tasks using a k-segment pipeline requires = k + (n-1) *tp
clock cycles.
‚Ä¢ For the non-pipelined processor :
‚Ä¢ Time to complete each task = tn
‚Ä¢ Total time required to complete n tasks=n*tn
‚Ä¢ Speed up = Time reqd. by non pipelining processing/Time reqd. by pipelining processing
ùëÜ = ùëá1

ùëáùêæ =

ùëõùë°ùëõ
(ùëò + (ùëõ ‚àí 1))ùë°ùëù


Speed Up and Efficiency
‚Ä¢ Latency of pipeline = no of stages * cycle time
‚Ä¢ Pipeline Cycle Time = Maximum delay due to any stage + Delay due to its register (Latch 
latency) 
‚Ä¢ Speed up = non pipelining processing/pipelining processing


Speed Up and Efficiency
‚Ä¢ As the number of tasks increases, n becomes much larger than k-1, and approaches 
the value of n. (i.e., k+n-1 becomes n at some point) 
‚Ä¢ Under this condition, speed up becomes 
S= tn / tp
‚Ä¢ Assume the time taken for pipeline and non pipeline circuits are same then tn = k*tp
‚Ä¢ Speed up reduces to S= (k*tp)/tp= k
‚Ä¢ This shows that the theoretical maximum speedup that a pipeline can provide is k, 
where k is the number of segments in the pipeline.


Time between 
Instruction

8

8

8

Time 
between 
Instruction

Time between 
Instruction

Time 
between 
Instruction

4 4

4

4

Speed up=

Time Between the instruction

Time Between the instruction

Unpipelined

pipelined

=

8
4

=2

What is your observation from speedup factor Vs No. of Stages

INS1 
INS2
INS3

INS1 
INS2
INS3

Evaluating Speed Up‚Ä¶


Pipelining ‚Äì Problem 1


Pipelining ‚Äì Problem 1


Evaluating Speed Up‚Ä¶ 
Five-Stage Pipeline

Simply start a new instruction on each clock cycle; 
Hence, Speedup = 5.


Pipelining ‚Äì Problem 2


Pipelining ‚Äì Problem 2


Pipelining ‚Äì Problem 3


Pipelining ‚Äì Problem 3

k + (n-1) clock cycles 


Pipelining ‚Äì Problem 4


Pipelining ‚Äì Problem 4


How to Design a PIPE‚Ä¶

‚Ä¢ Practically, it is difficult to divide instruction process into uniform stages 
‚Ä¢ Duration of stage equal to largest stage in the instruction process
‚Ä¢ All smaller stages are associated with latch to allow delay

Latch S1 Latch S2 Latch S3


Pipelining Lessons‚Ä¶
‚Ä¢ Pipelining - doesn‚Äôt help latency/ Turnaround of single task
- it helps throughput of entire workload
‚Ä¢ latency/ Turnaround: Complete single task in the smallest amount of 
time 
‚Ä¢ Throughput: Complete the most tasks in a fixed amount of time
‚Ä¢ Pipeline rate - limited by slowest pipeline stage 
‚Ä¢ Potential speedup = Number of pipe stages
‚Ä¢ Unbalanced lengths of pipe stages reduces speedup
‚Ä¢ Time to ‚Äúfill‚Äù pipeline and time to ‚Äúdrain‚Äù it reduces speedup


Pipelining ‚Äì Adv & Disadv
Advantages: 
‚Ä¢ More efficient use of processor
‚Ä¢ Quicker time of execution of large number of instructions
Disadvantages:
‚Ä¢ Pipelining involves adding hardware to the chip
‚Ä¢ Inability to continuously run the pipeline at full speed because of 
pipeline hazards which disrupt the smooth execution of the pipeline. 


Basic Performance Issues in 
Pipelining
‚Ä¢ Data hazards: When two instructions in a program are to be executed 
in sequence and both access a particular memory or register 
operand.
‚Ä¢ For example, if instruction A writes to a register that instruction B 
reads from, and instruction B is in an earlier stage than instruction
A.
‚Ä¢ Branching: Branch instructions can be problematic in a pipeline if a 
branch is conditional on the results of an instruction that has not yet 
completed its path through the pipeline.
‚Ä¢ Timing variations: The pipeline cannot take the same amount of time 
for all the stages.


Pipelining Hazards 
‚Ä¢ Hazard ‚Äì Any condition that make pipeline to stall. 
‚Ä¢ Stalling
‚Ä¢ A delay in instruction processing.
‚Ä¢ Itself can be used to resolve the hazard.
‚Ä¢ Types of Hazards
‚Ä¢ Structural Hazard
‚Ä¢ Data Hazard
‚Ä¢ Instructional/Control Hazard


Pipelining Hazards 
‚Ä¢ Data hazards (Data Dependency Conflicts) - An instruction scheduled to be 
executed in the pipeline requires the result of a previous instruction, which 
is not yet available.
‚Ä¢ occur when there are dependencies between instructions, that is, the
output of one instruction is an input to another.


Pipelining Hazards 
‚Ä¢ Data hazards (Data Dependency Conflicts)

‚Ä¢ Categories of Data Hazards:
‚Ä¢ data Read After Write hazards (RAW)
‚Ä¢ data Write After Read hazards (WAR)
‚Ä¢ data Write After Write hazards (WAW).


Pipelining Hazards 
‚Ä¢ Categories of Data Hazards:
‚Ä¢ data Read After Write hazards (RAW)
‚Ä¢ Also known as a true dependency - occurs when an instruction depends on the result of
a previous instruction.
‚Ä¢ data Write After Read hazards (WAR)
‚Ä¢ Also known as anti-dependency - occurs when an instruction depends on the reading of
a value before that value is overwritten by a previous instruction. 
‚Ä¢ data Write After Write hazards (WAW)
‚Ä¢ Also known as output-dependency - occurs when a value is written by an instruction
before the previous instruction writes that value.


Pipelining Hazards 
‚Ä¢ Structural hazards(Resource Conflicts) - Hardware Resources 
required by the instructions in simultaneous overlapped execution 
cannot be met.
‚Ä¢ These occur when the same hardware resource is desired by multiple
instructions at the same time.


Pipelining Hazards 

IF ID EX ME WB
IF ID EX ME WB
IF ID EX ME WB
IF ID EX ME WB
IF ID EX ME WB

Main Memory

Cache CPU Core

Memory

CPU

Instruction code 
Data

These two memory-access 
operations can not happen 
at the same time

lw $t1, 0($t2) 
instruction1 
instruction2 
instruction3

// Mem[$t2+0] ÔÇÆ$t1

Memory address is accessed 
and its content is loaded to 
this processor

Instruction3 is now 
‚Äúfetched‚Äù from memory

Structural Hazard - Occurrence


Pipelining Hazards 
‚Ä¢ Instructional/Control hazards (Branching, Memory delays) -
Branches and other instructions that change the PC make the fetch of 
the next instruction to be delayed.
‚Ä¢ Eg: Branch target address is not known until the branch instruction is 
completed


Instruction Execution in a 4-stage Pipeline 

Pipelining Hazards 
Instructional/Control hazards (Branching, Memory delays)


Ways to Resolve Data Hazard
‚Ä¢ Data Hazards - resolved by 
‚Ä¢ Hardware techniques 
‚Ä¢ interlock
‚Ä¢ Operand Forwarding (bypassing, short-circuiting)
‚Ä¢ Software techniques
‚Ä¢ Using NOP instructions
‚Ä¢ Instruction Scheduling(compiler) for delayed load

Hardware techniques: 
‚Ä¢ Interlock
- hardware detects the data dependencies and delays the scheduling of the 
dependent instruction by stalling enough clock cycles


Ways to Resolve Data Hazard
Hardware techniques:
‚Ä¢ Operand Forwarding (bypassing, short-circuiting)
‚Ä¢ Accomplished by a data path that routes a value from a source (usually an ALU) to a user, bypassing a 
designated register. 
‚Ä¢ This allows the value to be produced to be used at an earlier stage in the pipeline than would otherwise be 
possible 


Ways to Resolve Data Hazard
Software techniques:

Instruction Scheduling(compiler) 
for delayed load

Using NOP instructions


Ways to Resolve Structural 
Hazard
Structural Hazard - Occurrence Ways to Handle SH
‚Ä¢ Duplicate Resources
‚Ä¢ Pipeline the resources
‚Ä¢ Reordering the instructions


Ways to Resolve Control Hazard
‚Ä¢ Branch target address is not known until the branch instruction is 
completed
‚Ä¢ Handling Control Hazards
‚Ä¢ Prefetch Target Instruction 
‚Ä¢ Branch Target Buffer
‚Ä¢ Loop Buffer
‚Ä¢ Branch Prediction
‚Ä¢ Delayed Branch


Ways to Resolve Control Hazard
‚Ä¢ Prefetch Target Instruction
‚Ä¢ Fetch instructions in both streams, branch not taken and branch taken.
‚Ä¢ Both are saved until branch is executed. 
‚Ä¢ Then, select the right instruction stream and discard the wrong stream.
‚Ä¢ Branch Target Buffer (BTB; Associative Memory)
‚Ä¢ Entry: Address of previously executed branches; Target instruction and the 
next few instructions.
‚Ä¢ When fetching an instruction, search BTB.
‚Ä¢ If found - fetch the instruction stream in BTB; 
‚Ä¢ If not - new stream is fetched and update BTB.
‚Ä¢ The BTB typically has a 90% prediction accuracy 
and buffer hit rate.         


Ways to Resolve Control Hazard
‚Ä¢ Loop Buffer (High Speed Register file)
‚Ä¢ Storage of entire loop that allows to execute a loop without accessing 
memory
‚Ä¢ Branch Prediction
‚Ä¢ Guessing the branch condition, and fetch an 
instruction stream based on the guess.
‚Ä¢ Correct guess eliminates the branch penalty.


Ways to Resolve Control Hazard
‚Ä¢ Delayed Branch
‚Ä¢ Compiler detects the branch and rearranges the instruction sequence 
by inserting useful instructions that keep the pipeline busy in the 
presence of a branch instruction


BCSE205L
Computer Architecture and Organization
Module 7 ‚Äì Parallelism ‚Äì Superscalar Architecture


Scalar Architecture /Non-pipelined 
Architecture


Scalar Pipeline Architecture


Limitations of Scalar Pipeline


Limitations of Scalar Pipeline


Superscalar Architecture

Multi scalar Datapath


Superscalar Architecture


Superscalar Techniques
A more aggressive approach is to equip the processor with multiple processing units to handle several instructions 
in parallel in each processing stage. With this arrangement, several instructions start execution in the same clock 
cycle and the process is said to use multiple issue. Such processors are capable of achieving an instruction execution 
throughput of more than one instruction per cycle. They are known as ‚ÄòSuperscalar Processors‚Äô.


Super Pipeline Architecture 
‚Ä¢ Combination of Superscalar and Pipeline architectures


Superscalar Vs Superpipelined 
Architecture
‚Ä¢ Temporal parallelism- known as 
pipelining - way to execute a task as a 
series of sub-tasks, with one functional 
unit performing each sub-task.
‚Ä¢ All the successive units can work 
simultaneously, in an overlapped 
fashion.
‚Ä¢ Spatial parallelism - involves multiple 
tasks that are executed simultaneously, 
with each unit of information processed 
by its own dedicated component.


BCSE205L
Computer Architecture and Organization

Module 7 ‚Äì Performance Evaluation ‚Äì Amdahl‚Äôs Law, 
SpeedUp, Efficiency


Performance Evaluation of 
Superscalar & Parallel Processors
‚Ä¢ Performance Metrics of Parallel Processors
‚Ä¢ Speedup
‚Ä¢ Efficiency

‚Ä¢ Granularity Granularity = ùê∂ùëúùëöùëùùë¢ùë°ùëéùë°ùëñùëúùëõ ùëáùëñùëöùëí 
ùê∂ùëúùëöùëöùë¢ùëõùëñùëêùëéùë°ùëñùëúùëõ ùëáùëñùëöùëí
‚Ä¢ load balance


Performance Evaluation ‚Äì Speed Up


Performance Evaluation ‚Äì Speed Up
‚Ä¢ Example: Painting a picket fence
‚Ä¢ 30 minutes of preparation (serial)
‚Ä¢ One minute to paint a single picket 
‚Ä¢ 30 minutes of cleanup (serial) 
‚Ä¢ Thus, 300 pickets takes 360 minutes if 
processed in serial.

‚Ä¢ For N=1 (Serial) => SpeedUp = 360/360=1
‚Ä¢ For N=2 (Parallel) => SpeedUp = 360/210 = 1.7 
‚Ä¢ For N=10 (Parallel) => SpeedUp = 360/90 = 4
‚Ä¢ ‚Ä¶‚Ä¶‚Ä¶.


Performance Evaluation ‚Äì Efficiency
‚Ä¢ Efficiency
‚Ä¢ Measure of how effectively computation resources (threads) are kept busy

‚Ä¢ For N=1 (Serial) => Efficiency = 1/1*100 =100
‚Ä¢ For N=2 (Parallel) => Efficiency = 1.7/2 *100 =85 
‚Ä¢ For N=10 (Parallel) => Efficiency = 4/10 *100 =40 
‚Ä¢ ‚Ä¶‚Ä¶‚Ä¶.


Performance Evaluation of Parallel 
Processors ‚Äì Amdahl‚Äôs Law
‚Ä¢ Amdahl‚Äôs Law - SpeedUp Performance Law
‚ÄúLaw governing the speedup of using parallel processors on
a problem, versus using only one serial processor, under the 
assumption that the problem size remains the same when 
parallelized‚Äù.


Performance Evaluation of Parallel 
Processors ‚Äì Amdahl‚Äôs Law


Performance Evaluation of Parallel 
Processors ‚Äì Amdahl‚Äôs Law


Performance Evaluation of Parallel 
Processors ‚Äì Amdahl‚Äôs Law
‚Ä¢ SpeedUp ‚Äì Ratio of the time it takes to execute a program in serial(with one processor) 
to the time it takes to execute in parallel (with many processors)

‚Ä¢ Let

f = fraction of the execution time that involves code 
that is infinitely parallelizable with no scheduling overhead.
(1-f) = fraction of the execution time that involves 
code that is inherently sequential
T = Total execution time of the program using a single 
processor
Then, 


Performance Evaluation of Parallel 
Processors ‚Äì Amdahl‚Äôs Law
‚Ä¢ Two Important Conclusions drawn
‚Ä¢ When f is small, the use of parallel processors has little effect. 
‚Ä¢ As N approaches infinity, speedup is bound by 1/(1 - f), so that there are diminishing 
returns for using more processors.
‚Ä¢ Amdahl‚Äôs law can be generalized to evaluate any design 
or technical improvement in a computer system. 
‚Ä¢ Consider any enhancement to a feature of a system that 
results in a speedup. 
The speedup can be expressed as


Performance Evaluation of Parallel 
Processors ‚Äì Amdahl‚Äôs Law
‚Ä¢ The speedup can be expressed as

‚Ä¢ Suppose that a feature of the system 
is enhanced to improve the 
performance. 
‚Ä¢ Let f = a fraction of the time before 
enhancement (fE)
‚Ä¢ Suf = speedup of that feature after 
enhancement 
‚Ä¢ Then the overall speedup 
of the system is

Amdahl‚Äôs Law ‚Äì for Fraction 
Enhancement
Consider fE ‚Äì Fraction Enhanced (f)
1-fE ‚Äì Unaffected Fraction (1-f)
fI = Factor of Improvement (SUf or N)
Then the overall speedup of the system is


Performance Evaluation ‚Äì Problems
‚Ä¢ N=8

Problem 1

f = 0.7 
1-f = 0.3 
N=8 

Speedup = 1 
0.3+0.7
8

= 1 
0.3+0.0875

= 1 
0.3875

= 2.6


Performance Evaluation ‚Äì Problems
Problem 2

f = 0.8 
1-f = 0.2 
N=8 

Speedup = 1 
0.2+0.8
8

= 1 
0.2+0.1

= 1 
0.3

= 3.33


Performance Evaluation ‚Äì Problems
Problem 3

f = 0.95 
1-f = 0.05 
N=8 

Speedup = 1 
0.05+0.95
8

= 5.9


Performance Evaluation ‚Äì Problems
Problem 4

f = 10% = 0.1 
1-f = 0.9
N=4 

Speedup = 1 
0.9+0.1
4

= 1 
0.9+0.025

= 1 
0.925

= 1.081

We have 4 processors and only 10% of the code is parallelizable. Find the 
speed up.


Performance Evaluation ‚Äì Problems 
‚Äì Overall Speedup
Problem 5 ‚Äì Finding Overall speed up - Given, speedup of the enhanced 
machine.

f = 10% = 0.1
1-f = 0.9
Speedup of enhanced machine (SUf)=2 
Speedup = 1 
0.9+0.1
2

= 1 
0.9+0.05

= 1 
0.95

= 1.053
Speedup = 1 
0.9+ 0.1
100

= 1.109


Hint: (Similarity) 
Consider 
‚Ä¢ fE ‚Äì Fraction Enhanced (f)
‚Ä¢ 1-fE ‚Äì Unaffected Fraction (1-f)
‚Ä¢ fI = Factor of Improvement (SUf or N)

Amdahl‚Äôs Law ‚Äì for Fraction 
Enhancement
Consider fE ‚Äì Fraction Enhanced (f)
1-fE ‚Äì Unaffected Fraction (1-f)
fI = Factor of Improvement (SUf or N)
Then the overall speedup of the system is

Problem 6


Hint: (Similarity) 
Consider fE ‚Äì Fraction Enhanced (f)
‚Ä¢ 1-fE ‚Äì Unaffected Fraction (1-f)
‚Ä¢ fI = Factor of Improvement (SUf or N)

Problem 7


Hint: (Similarity) 
Consider fE ‚Äì Fraction Enhanced (f)
‚Ä¢ 1-fE ‚Äì Unaffected Fraction (1-f)
‚Ä¢ fI = Fraction of Enhancement (SUf or N)

Problem 8


Hint: (Similarity) 
Consider fE ‚Äì Fraction Enhanced (f)
‚Ä¢ 1-fE ‚Äì Unaffected Fraction (1-f)
‚Ä¢ fI = Fraction of Enhancement (SUf or N)

Problem 9


Problem 10


Problem 11


Problem 12